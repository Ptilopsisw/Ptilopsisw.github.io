[{"title":"板子","url":"/2022/05/19/%E6%9D%BF%E5%AD%90/","content":"快读update5现在可以用小数辣！支持float和double(当然long double勉强能用，出锅了别来找我qwq).\n保留小数的话可以用setpcs()函数，例如setpcs(5)就是按四舍五入保留 $ 5 $ 位小数.\n可以用 cout &lt;&lt; setpcs(5) &lt;&lt; ans; 或者 print(setpcs(5), ans); 两种方法.\n也可以在程序最开头写上setpcs(5),这样所有小数输出都会保留 $ 5 $ 位小数了.\nupdate4可以用 read&lt;int&gt;() 获得一个 int 型数据，或者 read&lt;long long&gt;() 获得一个 long long 型数据,即 a = read&lt;int&gt;() ，但是只能读整数，不要传入字符串或浮点数.\nupdate3已通过 #ifdef 方式实现在OJ上用 fread ,在本地上用 cstdio 库输入输出，本地debug不需要文件读写了.\nupdate2可以用 io&gt;&gt;a&gt;&gt;b , io&lt;&lt;a&lt;&lt;b, io&gt;&gt;a&lt;&lt;a ，还写上了 #define cin io , #define cout io , #define endl &#39;\\n&#39; ，使用 cin 的话可以直接把板子贴上去无需修改.\nupdate1已修复无法while(read(a))的bug.\n          C++ 共 165 行                      展开    namespace fast_IO&#123;    #define FASTIO    #define IOSIZE 100000    char ibuf[IOSIZE], obuf[IOSIZE];    char *p1 = ibuf, *p2 = ibuf, *p3 = obuf;    int pcs;    #ifdef ONLINE_JUDGE        #define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))        #define putchar(x) ((p3==obuf+IOSIZE)&amp;&amp;(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)    #endif//fread in OJ, stdio in local        #define isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)    #define isspace(ch) (ch&lt;33)        struct pcs_t&#123;&#125;;    pcs_t setpcs(int cnt)    &#123;        pcs = cnt;        return pcs_t();    &#125;    template&lt;typename T&gt; inline T read()    &#123;        T s = 0; int w = 1; char ch;        while(ch=getchar(),!isdigit(ch)and(ch!=EOF)) if(ch==&#x27;-&#x27;) w=-1;        if(ch == EOF) return false;        while(isdigit(ch)) s=s*10+ch-48,ch=getchar();        if(ch == &#x27;.&#x27;)        &#123;            long long cnt = 1, flt = 0;            while(ch=getchar(),isdigit(ch))                if(cnt &lt; 1e18)                    flt = flt*10+ch-48, cnt *= 10;            s += (double)flt/cnt;        &#125;        return s*=w;    &#125;    template&lt;typename T&gt; inline bool read(T &amp;s)    &#123;        s = 0; int w = 1; char ch;        while(ch=getchar(),!isdigit(ch)and(ch!=EOF)) if(ch==&#x27;-&#x27;) w=-1;        if(ch == EOF) return false;        while(isdigit(ch)) s=s*10+ch-48,ch=getchar();        if(ch == &#x27;.&#x27;)        &#123;            long long cnt = 1, flt = 0;            while(ch=getchar(),isdigit(ch))                if(cnt &lt; 1e18)                    flt = flt*10+ch-48, cnt *= 10;            s += (double)flt/cnt;        &#125;        return s*=w, true;    &#125;    inline bool read(char &amp;s)    &#123;        while(s = getchar(), isspace(s));        return true;    &#125;    inline bool read(char *s)    &#123;        char ch;        while(ch=getchar(),isspace(ch));        if(ch == EOF) return false;        while(!isspace(ch)) *s++ = ch, ch = getchar();        *s = &#x27;\\000&#x27;; return true;    &#125;    template&lt;typename T&gt; inline void print(T x)    &#123;        if(x &lt; 0) putchar(&#x27;-&#x27;), x = -x;        if(x &gt; 9) print(x/10);        putchar(x%10+48);    &#125;    inline void print(pcs_t x)&#123; return void(); &#125;    inline void print(double x)    &#123;        if(x &lt; 0) putchar(&#x27;-&#x27;), x = -x;        x += 5.0/pow(10,pcs+1);        print((long long)(x));        x -= (long long)(x);        putchar(&#x27;.&#x27;);        for(int i = 1; i &lt;= pcs; i++)        &#123;            x *= 10;            putchar((int)x+&#x27;0&#x27;);            x -= (int)x;        &#125;    &#125;    inline void print(float x)    &#123;        x += (x&lt;0?-1:1)*5.0/pow(10,pcs+1);        print((long long)(x));        x -= (long long)(x); x = abs(x);        putchar(&#x27;.&#x27;);        for(int i = 1; i &lt;= pcs; i++)        &#123;            x *= 10;            putchar((int)x+&#x27;0&#x27;);            x -= (int)x;        &#125;    &#125;    inline void print(long double x)    &#123;        x += (x&lt;0?-1:1)*5.0/pow(10,pcs+1);        print((__int128_t)(x));        x -= (__int128_t)(x); x = abs(x);        putchar(&#x27;.&#x27;);        for(int i = 1; i &lt;= pcs; i++)        &#123;            x *= 10;            putchar((int)x+&#x27;0&#x27;);            x -= (int)x;        &#125;    &#125;    inline void print(char x)&#123; putchar(x); &#125;    inline void print(char *x)&#123; while(*x) putchar(*x++); &#125;    inline void print(const char *x)    &#123; for(int i = 0; x[i]; i++) putchar(x[i]); &#125;    #ifdef _GLIBCXX_STRING//string        inline bool read(std::string&amp; s)        &#123;            s = &quot;&quot;; char ch;            while(ch=getchar(),isspace(ch));            if(ch == EOF) return false;            while(!isspace(ch)) s += ch, ch = getchar();            return true;        &#125;        inline void print(std::string x)        &#123;            for(int i = 0, n = x.size(); i &lt; n; i++)                putchar(x[i]);        &#125;    #endif    template&lt;typename T, typename... T1&gt; inline int read(T&amp; a, T1&amp;... other)&#123; return read(a)+read(other...); &#125;    template&lt;typename T, typename... T1&gt; inline void print(T a, T1... other)&#123; print(a); print(other...); &#125;        struct fast_IO_t&#123;        fast_IO_t()&#123; setpcs(10); &#125;        ~fast_IO_t()&#123; fwrite(obuf, p3-obuf, 1, stdout); &#125;        bool flag = false;        operator bool()&#123; return flag; &#125;    &#125;io;    template&lt;typename T&gt; fast_IO_t&amp; operator &gt;&gt; (fast_IO_t &amp;io, T &amp;b)&#123; return io.flag = read(b), io; &#125;    template&lt;typename T&gt; fast_IO_t&amp; operator &lt;&lt; (fast_IO_t &amp;io, T b)&#123; return print(b), io; &#125;    #define cout io    #define cin io    #define endl &#x27;\\n&#x27;&#125;using namespace fast_IO;\n\n高精支持除位运算符外所有运算符，请通过修改bigint_SIZE来修改高精数长度\ntips: 除法有一点慢\n输入输出可以用成员函数(bigint).input()和(bigint).print()，也可以用read(bigint&amp;)和print(bigint)\n          C++ 共 335 行                      展开    namespace bigint_space&#123;    const int bigint_SIZE = 505;    char bigint_input[bigint_SIZE];    bool division_compare(short *a, int lena, short *b, int lenb)    &#123;        if(lena != lenb)            return lena &gt; lenb;        for(int i = 1; i &lt;= lena; i++)        &#123;            if(a[i] != b[i])                return a[i] &gt; b[i];        &#125;        return true;    &#125;    void division_minus(short *a, int lena, short *b, int lenb)    &#123;        int f = lena != lenb;        for(int i = lena; i &gt;= 1; i--)        &#123;            a[i] -= b[i-f];            if(a[i] &lt; 0)                a[i] += 10, a[i-1]--;        &#125;    &#125;    class bigint&#123;        private:            int len;            short s[bigint_SIZE];            bool less0;        public:            bigint(long long x = 0)            &#123;                std::memset(s, 0, sizeof(s));                len = 0; less0 = false;                if(x == 0)                &#123;                    len = 1;                    return;                &#125;                if(x &lt; 0)                    less0 = true, x = -x;                while(x != 0)                    s[++len] = x%10, x /= 10;            &#125;            void clear()&#123; std::memset(s,0,sizeof(s)); len=1; &#125;            void input()            &#123;                std::memset(s, 0, sizeof(s));                std::memset(bigint_input, 0, sizeof(bigint_input));                len = 0;                char ch = getchar();                while(!isdigit(ch))                &#123;                    if(ch == &#x27;-&#x27;)                        less0 = true;                    ch = getchar();                &#125;                while(isdigit(ch))                &#123;                    bigint_input[++len] = ch;                    ch = getchar();                &#125;                for(int i = 1; i &lt;= len; i++)                    s[i] = bigint_input[len-i+1]-48;                #ifdef getchar                    ibufp1--;                #endif            &#125;            void print()            &#123;                if(less0) putchar(&#x27;-&#x27;);                for(int i = len; i &gt;= 1; i--)                    putchar(s[i]+48);            &#125;            friend bigint operator + (bigint a, bigint b)            &#123;                bigint c;                c.len = a.len &gt; b.len ? a.len : b.len;                if(a.less0 &amp;&amp; b.less0)                    return -(-a + -b);                if(a.less0)                    return b-abs(a);                if(b.less0)                    return a-abs(b);                                for(int i = 1; i &lt;= c.len+1; i++)                &#123;                    c.s[i] += a.s[i]+b.s[i];                    c.s[i+1] += c.s[i]/10;                    c.s[i] %= 10;                &#125;                if(c.s[c.len+1] != 0)                c.len++;                return c;            &#125;            friend bigint operator - (bigint a)            &#123;                a.less0 = !a.less0;                return a;            &#125;            friend bigint operator - (bigint a, bigint b)            &#123;                if(b.less0)                    return a+abs(b);                if(a.less0)                    return -(abs(a)+b);                if(a &lt; b)                    return -(b-a);                bigint c;                c.len = a.len &gt; b.len ? a.len : b.len;                for(int i = 1; i &lt;= c.len; i++)                &#123;                    c.s[i] = a.s[i]-b.s[i];                    if(c.s[i] &lt; 0)                        a.s[i+1]--, c.s[i] += 10;                &#125;                while(c.s[c.len] == 0 and c.len &gt; 1)                    c.len--;                return c;            &#125;            friend bigint operator * (bigint a, bigint b)            &#123;                bigint c;                c.less0 = a.less0 ^ b.less0;                for(int i = 1; i &lt;= b.len; i++)                    for(int j = 1; j &lt;= a.len; j++)                        c.s[i+j-1] += a.s[j]*b.s[i];                c.len = a.len+b.len;                for(int i = 1; i &lt;= c.len; i++)                &#123;                    c.s[i+1] += c.s[i]/10;                    c.s[i] %= 10;                &#125;                while(c.s[c.len] == 0 and c.len &gt; 1)                    c.len--;                return c;            &#125;            friend bigint operator / (bigint a, long long b)            &#123;                if(abs(a) &lt; abs(b))                    return 0;                bigint c;                c.len = a.len;                long long tot = 0;                for(int i = a.len; i &gt;= 1; i--)                &#123;                    tot *= 10;                    tot += a.s[i];                    if(tot &gt;= b)                    &#123;                        c.s[i] = tot/b;                        tot %= b;                    &#125;                &#125;                while(c.s[c.len] == 0 and c.len &gt; 1)                    c.len--;                c.less0 = a.less0 ^ (b&lt;0);                return c;            &#125;            friend bigint operator / (bigint a,bigint b)            &#123;                if(abs(a) &lt; abs(b))                    return 0;                bigint c;                c.len = a.len-b.len+1;                c.less0 = a.less0 ^ b.less0;                short abuf[bigint_SIZE]; int top = 0;                short bbuf[bigint_SIZE];                memset(abuf, 0, sizeof(abuf));                memset(bbuf, 0, sizeof(bbuf));                for(int i = b.len; i &gt;= 1; i--)                    bbuf[i] = b.s[b.len-i+1];                for(int i = a.len; i &gt;= 1;)                &#123;                    while(!division_compare(abuf, top, bbuf, b.len) and i &gt; 0)                    &#123;                        if(!(top == 0 and a.s[i] == 0))                            abuf[++top] = a.s[i];                        i--;                    &#125;                    while(division_compare(abuf, top, bbuf, b.len))                    &#123;                        division_minus(abuf, top, bbuf, b.len);                        c.s[i+1]++;                        int tot = 0;                        for(int j = 1; j &lt;= top; j++)                        &#123;                            if(abuf[j] != 0)                                break;                            tot++;                        &#125;                        if(tot != 0)                        &#123;                            for(int j = 1; j &lt;= top-tot; j++)                                abuf[j] = abuf[j+tot], abuf[j+tot] = 0;                            top -= tot;                        &#125;                    &#125;                &#125;                while(c.s[c.len] == 0 and c.len &gt; 1)                    c.len--;                return c;            &#125;            friend bigint operator % (bigint a, bigint b)            &#123;                bigint c;                c.less0 = 0;                short abuf[bigint_SIZE]; int top = 0;                short bbuf[bigint_SIZE];                memset(abuf, 0, sizeof(abuf));                memset(bbuf, 0, sizeof(bbuf));                for(int i = b.len; i &gt;= 1; i--)                    bbuf[i] = b.s[b.len-i+1];                for(int i = a.len; i &gt;= 1;)                &#123;                    while(!division_compare(abuf, top, bbuf, b.len) and i &gt; 0)                    &#123;                        if(!(top == 0 and a.s[i] == 0))                            abuf[++top] = a.s[i];                        i--;                    &#125;                    while(division_compare(abuf, top, bbuf, b.len))                    &#123;                        division_minus(abuf, top, bbuf, b.len);                        int tot = 0;                        for(int j = 1; j &lt;= top; j++)                        &#123;                            if(abuf[j] != 0)                                break;                            tot++;                        &#125;                        if(tot != 0)                        &#123;                            for(int j = 1; j &lt;= top-tot; j++)                                abuf[j] = abuf[j+tot], abuf[j+tot] = 0;                            top -= tot;                        &#125;                    &#125;                &#125;                c.len = (top==0)?1:top;                for(int i = top; i &gt;= 1; i--)                    c.s[top-i+1] = abuf[i];                while(c.s[c.len] == 0 and c.len &gt; 1)                    c.len--;                return c;            &#125;            friend bigint operator ++ (bigint &amp;a) &#123; return (a = a+1); &#125;            bigint operator ++ (int)&#123;                bigint a = *this;                *this = (*this)+1;                return a;            &#125;            friend bigint operator -- (bigint &amp;a) &#123; return (a = a-1); &#125;            bigint operator -- (int)&#123;                bigint a = *this;                *this = *this - 1;                return a;            &#125;            bigint operator = (long long x)&#123;                std::memset(s, 0, sizeof(s));                len = 0; less0 = false;                if(x == 0)                &#123;                    len = 1;                    return *this;                &#125;                if(x &lt; 0)                    less0 = true, x = -x;                while(x != 0)                    s[++len] = x%10, x /= 10;                return *this;            &#125;            friend bool operator &gt; (bigint a, bigint b)            &#123;                if(a.less0 != b.less0)                    return a.less0 &lt; b.less0;                bool ans = false;                if(a.len != b.len)                    ans = a.len &gt; b.len;                else                &#123;                    for(int i = a.len; i &gt;= 1; i--)                        if(a.s[i] != b.s[i])                        &#123;                            ans = a.s[i] &gt; b.s[i];                            break;                        &#125;                &#125;                return (a.less0 and b.less0) ? !ans : ans;            &#125;            friend bool operator &lt; (bigint a, bigint b)            &#123;                if(a.less0 != b.less0)                    return a.less0 &gt; b.less0;                bool ans = false;                if(a.len != b.len)                    ans = a.len &lt; b.len;                else                &#123;                    for(int i = a.len ; i &gt;= 1; i--)                        if(a.s[i] != b.s[i])                        &#123;                            ans = a.s[i] &lt; b.s[i];                            break;                        &#125;                &#125;                return (a.less0 and b.less0) ? !ans : ans;            &#125;            friend bool operator == (bigint a, bigint b)            &#123;                if(a.less0 != b.less0)                    return false;                if(a.len != b.len)                    return false;                for(int i = 1; i &lt;= a.len; i++)                    if(a.s[i] != b.s[i])                        return false;                return true;            &#125;            friend bool operator &gt;= (bigint a, bigint b) &#123; return !(a&lt;b); &#125;            friend bool operator &lt;= (bigint a, bigint b) &#123; return !(a&gt;b); &#125;            friend bool operator != (bigint a, bigint b) &#123; return !(a==b); &#125;            friend bigint max(bigint a, bigint b)&#123; return a&gt;b?a:b; &#125;            friend bigint min(bigint a, bigint b)&#123; return a&lt;b?a:b; &#125;            friend bigint abs(bigint a)&#123; a.less0 = false; return a; &#125;            bigint operator += (bigint a)&#123; return *this = *this+a; &#125;            bigint operator -= (bigint a)&#123; return *this = *this-a; &#125;            bigint operator *= (bigint a)&#123; return *this = *this*a; &#125;            bigint operator /= (bigint a)&#123; return *this = *this/a; &#125;            bigint operator %= (bigint a)&#123; return *this = *this%a; &#125;    &#125;;    void read(bigint &amp;a)&#123; a.input(); &#125;    void print(bigint a) &#123; a.print(); &#125;&#125;using namespace bigint_space;\n\n矩阵运算声明一个矩阵: matrix a;\n支持 + , - , * , % , 下标访问和快速幂.\n注意：为了方便debug，在不满足运算法则进行运算时会直接退出程序并输出 Matrix error!\n默认矩阵大小为 Xsize , Ysize ，可自行修改我也写了构造函数，可以用 matrix a(10,10) 来手动规定矩形的长和宽.\n默认情况下矩阵内全为0，可以通过下标访问修改矩阵内元素的值.\n默认情况下矩阵内元素类型为 int ，可以修改 #define type int 来修改元素类型.\n默认情况下矩阵自动对 INT_MAX 取模，你也可以修改这个自动模数，在 const type mod = INT_MAX 处可以修改.\n为了debug方便你可以直接 print(matrix) 来输出一个矩阵.\n我内部是用一个 vector&lt;vector&lt;type&gt;&gt; 实现的矩阵(二维数组太不灵活了)，常数有点大请见谅，但是我找不到更好的写法来实现矩阵了，如果有速度更快的办法可以私信我，我尽量更新( .\n          C++ 共 98 行                      展开    namespace Matrix&#123;    #define type int    const int Xsize = 80;    const int Ysize = 80;    const type mod = INT_MAX;        struct matrix    &#123;        vector&lt;vector&lt;type&gt;&gt; a;        int xlen, ylen;        matrix(int x=Xsize, int y=Ysize)        &#123;            xlen = x, ylen = y;            a.resize(x+1);            for(int i = 1; i &lt;= x; i++)            &#123;                a[i].resize(y+1);                a[i].assign(y+1, 0);            &#125;        &#125;        vector&lt;type&gt;&amp; operator [] (int x)        &#123;            return a[x];        &#125;    &#125;;    void throw_error()    &#123;        cout &lt;&lt; &quot;Matrix error!&quot;;        std::exit(0);    &#125;    matrix operator + (matrix a, matrix b)    &#123;        if(a.xlen != b.xlen or a.ylen != b.ylen)            throw_error();        for(int i = 1; i &lt;= a.xlen; i++)        for(int j = 1; j &lt;= a.ylen; j++)            (a[i][j] += b[i][j]) %= mod;        return a;    &#125;    matrix operator - (matrix a, matrix b)    &#123;        if(a.xlen != b.xlen or a.ylen != b.ylen)            throw_error();        for(int i = 1; i &lt;= a.xlen; i++)        for(int j = 1; j &lt;= a.ylen; j++)            (a[i][j] -= b[i][j]) %= mod;        return a;    &#125;    matrix operator * (matrix a, matrix b)    &#123;        if(a.ylen != b.xlen) throw_error();        matrix ans(a.xlen, b.ylen);        for(int i = 1; i &lt;= a.xlen; i++)        for(int j = 1; j &lt;= b.ylen; j++)        for(int k = 1; k &lt;= a.ylen; k++)            (ans[i][j] += a[i][k]*b[k][j]) %= mod;        return ans;    &#125;    matrix operator * (matrix a, type k)    &#123;        for(int i = 1; i &lt;= a.xlen; i++)        for(int j = 1; j &lt;= a.ylen; j++)            (a[i][j] *= k) %= mod;        return a;    &#125;    matrix operator % (matrix a, type k)    &#123;        for(int i = 1; i &lt;= a.xlen; i++)        for(int j = 1; j &lt;= a.ylen; j++)            a[i][j] %= k;        return a;    &#125;    matrix&amp; operator += (matrix &amp;a, matrix b)&#123; return (a = a+b); &#125;    matrix&amp; operator -= (matrix &amp;a, matrix b)&#123; return (a = a-b); &#125;    matrix&amp; operator *= (matrix &amp;a, matrix b)&#123; return (a = a*b); &#125;    matrix&amp; operator *= (matrix &amp;a, type k)&#123; return (a = a*k); &#125;    matrix&amp; operator %= (matrix &amp;a, type k)&#123; return (a = a%k); &#125;    matrix pow(matrix a, long long p, type k=mod)    &#123;        if(a.xlen != a.ylen) throw_error();        matrix ans(a.xlen, a.ylen);        for(int i = 1; i &lt;= a.xlen; i++)            ans[i][i] = 1;        for(; p; p &gt;&gt;= 1, (a *= a) %= k)            if(p&amp;1) (ans *= a) %= k;        return ans;    &#125;    void print(matrix a)    &#123;        for(int i = 1; i &lt;= a.xlen; i++)        &#123;            for(int j = 1; j &lt;= a.ylen; j++)                cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;            cout &lt;&lt; endl;        &#125;    &#125;&#125;using namespace Matrix;","categories":["114514"]}]