<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快读快写板子</title>
    <url>/2022/06/05/%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>通过 <code>read()</code> 和 <code>print()</code> 进行输入输出， 也可以用 <code>cin</code> , <code>cout</code> (我已经define了)。</p>
<p>千万不要快读快写和 <code>cstdio</code> 混用！！！！</p>
<p><code>read()</code> 可以传入任意c++关键字类型和<code>string</code>(小数也可以)。</p>
<p><code>read()</code> 和 <code>print()</code> 也可以传入多个参数，即使不同类型也可以。(c++98不支持)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="type">char</span> b;</span><br><span class="line"><span class="built_in">read</span>(a, b); <span class="comment">// OK, no problem</span></span><br></pre></td></tr></table></figure>
<p>输出小数时，使用<code>setpcs(x)</code>来保留精度(四舍五入)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">setpcs</span>(<span class="number">5</span>), x);</span><br><span class="line">cout &lt;&lt; <span class="built_in">setpcs</span>(<span class="number">5</span>) &lt;&lt; x;</span><br></pre></td></tr></table></figure>
<p>读入 <code>char</code> 类型时，会自动过滤掉空格(读入第一个不是空格的字符)，效果跟<code>cin</code>一样。</p>
<p>如果想要读入一整行，可以用<code>getline(cin, string)</code>(字符数组的我懒得写了)。</p>
<p>根据使用习惯也可以用 <code>a = read&lt;int&gt;()</code> 的方式读入。</p>
<p><code>read()</code> 函数会返回成功读入了几个数据，可以用来判断是否到达读入文件结尾。<br><code>cin &gt;&gt; a</code> 也会返回是否读入成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(a,b) == <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b);</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fast_IO</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FAST_IO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> IOSIZE 100000</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">__int128_t</span> i128;</span><br><span class="line">    <span class="type">char</span> ibuf[IOSIZE], obuf[IOSIZE];</span><br><span class="line">    <span class="type">char</span> *p1 = ibuf, *p2 = ibuf, *p3 = obuf;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> putchar(x) ((p3==obuf+IOSIZE)&amp;&amp;(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span><span class="comment">//fread in OJ, stdio in local</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> isdigit(ch) (ch&gt;47&amp;&amp;ch&lt;58)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> isspace(ch) (ch&lt;33&amp;&amp;ch!=EOF)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fast_IO_t</span>&#123;</span><br><span class="line">        ~<span class="built_in">fast_IO_t</span>()&#123;</span><br><span class="line">            <span class="built_in">fwrite</span>(obuf, p3-obuf, <span class="number">1</span>, stdout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;io;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T s = <span class="number">0</span>; <span class="type">int</span> w = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), !<span class="built_in">isdigit</span>(ch)&amp;&amp;(ch!=EOF))</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">            s = s*<span class="number">10</span>+ch<span class="number">-48</span>, ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            ll flt = <span class="number">0</span>; <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), <span class="built_in">isdigit</span>(ch))</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; <span class="number">18</span>) flt=flt*<span class="number">10</span>+ch<span class="number">-48</span>, cnt++;</span><br><span class="line">            s += (db)flt/<span class="built_in">pow</span>(<span class="number">10</span>,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s *= w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(T &amp;s)</span> </span>&#123;</span><br><span class="line">        s = <span class="number">0</span>; <span class="type">int</span> w = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), !<span class="built_in">isdigit</span>(ch)&amp;&amp;(ch!=EOF))</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">            s = s*<span class="number">10</span>+ch<span class="number">-48</span>, ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            ll flt = <span class="number">0</span>; <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), <span class="built_in">isdigit</span>(ch))</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; <span class="number">18</span>) flt=flt*<span class="number">10</span>+ch<span class="number">-48</span>, cnt++;</span><br><span class="line">            s += (db)flt/<span class="built_in">pow</span>(<span class="number">10</span>,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s *= w, <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(<span class="type">char</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s = <span class="built_in">getchar</span>(), <span class="built_in">isspace</span>(s));</span><br><span class="line">        <span class="keyword">return</span> s != EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), <span class="built_in">isspace</span>(ch));</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isspace</span>(ch))</span><br><span class="line">            *s++ = ch, ch=<span class="built_in">getchar</span>();</span><br><span class="line">        *s = <span class="string">&#x27;\000&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> t[<span class="number">20</span>]; <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">do</span> &#123; t[++top] = x%<span class="number">10</span>; x /= <span class="number">10</span>; &#125; <span class="keyword">while</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(top) <span class="built_in">putchar</span>(t[top--]+<span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">null_type</span>&#123;&#125;; <span class="type">int</span> pcs = <span class="number">8</span>;</span><br><span class="line">    <span class="function">null_type <span class="title">setpcs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pcs = cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(null_type x)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        x += <span class="number">5.0</span> / <span class="built_in">pow</span>(<span class="number">10</span>,pcs+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>((ll)(x)); x -= (ll)(x);</span><br><span class="line">        <span class="keyword">if</span>(pcs != <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pcs; i++)</span><br><span class="line">            x *= <span class="number">10</span>, <span class="built_in">putchar</span>((<span class="type">int</span>)x+<span class="string">&#x27;0&#x27;</span>), x -= (<span class="type">int</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        x += <span class="number">5.0</span> / <span class="built_in">pow</span>(<span class="number">10</span>,pcs+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>((ll)(x)); x -= (ll)(x);</span><br><span class="line">        <span class="keyword">if</span>(pcs != <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pcs; i++)</span><br><span class="line">            x *= <span class="number">10</span>, <span class="built_in">putchar</span>((<span class="type">int</span>)x+<span class="string">&#x27;0&#x27;</span>), x -= (<span class="type">int</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> <span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        x += <span class="number">5.0</span> / <span class="built_in">pow</span>(<span class="number">10</span>,pcs+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>((i128)(x)); x -= (i128)(x);</span><br><span class="line">        <span class="keyword">if</span>(pcs != <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pcs; i++)</span><br><span class="line">            x *= <span class="number">10</span>, <span class="built_in">putchar</span>((<span class="type">int</span>)x+<span class="string">&#x27;0&#x27;</span>), x -= (<span class="type">int</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; x[i]; i++)</span><br><span class="line">            <span class="built_in">putchar</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; x[i]; i++)</span><br><span class="line">            <span class="built_in">putchar</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _GLIBCXX_STRING<span class="comment">//string</span></span></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(std::string&amp; s)</span> </span>&#123;</span><br><span class="line">            s = <span class="string">&quot;&quot;</span>; <span class="type">char</span> ch;</span><br><span class="line">            <span class="keyword">while</span>(ch=<span class="built_in">getchar</span>(), <span class="built_in">isspace</span>(ch));</span><br><span class="line">            <span class="keyword">if</span>(ch == EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isspace</span>(ch))</span><br><span class="line">                s += ch, ch = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::string x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(string::iterator i = x.<span class="built_in">begin</span>(); i != x.<span class="built_in">end</span>(); i++)</span><br><span class="line">                <span class="built_in">putchar</span>(*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">getline</span><span class="params">(fast_IO_t &amp;io, string s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            s = <span class="string">&quot;&quot;</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(ch == EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(ch != <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> ch != EOF)</span><br><span class="line">                s += ch, ch = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... T1&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">(T&amp; a, T1&amp;... other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">read</span>(a)+<span class="built_in">read</span>(other...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... T1&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(T a, T1... other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(a); <span class="built_in">print</span>(other...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    fast_IO_t&amp; <span class="keyword">operator</span> &gt;&gt; (fast_IO_t &amp;io, T &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> io.flag=<span class="built_in">read</span>(b), io;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    fast_IO_t&amp; <span class="keyword">operator</span> &lt;&lt; (fast_IO_t &amp;io, T b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(b), io;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> cout io</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> cin io</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fast_IO;</span><br></pre></td></tr></table></figure>
<p>使用时如发现任何bug，都可在评论区提出，我会尽快修复</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>Command Runner 透彻指南(VSCode)</title>
    <url>/2022/06/28/Command%20Runner%20%E9%80%8F%E5%BD%BB%E6%8C%87%E5%8D%97(VSCode)/</url>
    <content><![CDATA[<h1 id="Command-Runner-透彻指南（VSCode）"><a href="#Command-Runner-透彻指南（VSCode）" class="headerlink" title="Command Runner 透彻指南（VSCode）"></a>Command Runner 透彻指南（VSCode）</h1><p><del>虽然我不太懂json没有真正透彻吧</del><br><del>但我还是要说:垃圾code-runner</del></p>
<h3 id="这里是懒人专属"><a href="#这里是懒人专属" class="headerlink" title="这里是懒人专属"></a>这里是懒人专属</h3><ol>
<li>在 VSCode 中安装 Command Runner 插件</li>
</ol>
<ol>
<li>在settings.json中把下面的代码加进去就行了</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;command-runner.commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compile-cpp&quot;</span><span class="punctuation">:</span>      <span class="string">&quot; cls &amp;&amp; cd /d \&quot;$&#123;fileDirname&#125;\&quot; &amp;&amp; g++ -std=c++14 -O2 \&quot;$&#123;fileBasenameNoExtension&#125;.cpp\&quot; -o \&quot;$&#123;fileBasenameNoExtension&#125;.exe\&quot; -g &amp;&amp; echo Compile completed! &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;run-cpp&quot;</span><span class="punctuation">:</span>          <span class="string">&quot; cls &amp;&amp; cd /d \&quot;$&#123;fileDirname&#125;\&quot; &amp;&amp; echo The program is running! &amp;&amp; echo ------------------------------------------ &amp;&amp; \&quot;$&#123;fileBasenameNoExtension&#125;.exe\&quot; &amp;&amp; echo, &amp;&amp; echo ------------------------------------------ &amp;&amp; echo The program has finished!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;compile&amp;run-cpp&quot;</span><span class="punctuation">:</span>  <span class="string">&quot; cls &amp;&amp; cd /d \&quot;$&#123;fileDirname&#125;\&quot; &amp;&amp; g++ -std=c++14 -O2 \&quot;$&#123;fileBasenameNoExtension&#125;.cpp\&quot; -o \&quot;$&#123;fileBasenameNoExtension&#125;.exe\&quot; -g &amp;&amp; echo The program is running! &amp;&amp; echo ------------------------------------------ &amp;&amp; \&quot;$&#123;fileBasenameNoExtension&#125;.exe\&quot; &amp;&amp; echo, &amp;&amp; echo ------------------------------------------ &amp;&amp; echo The program has finished!&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在keybingdings.json中把下面代码加进去就行了</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;F9&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command-runner.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;compile-cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runCommand&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;F10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command-runner.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run-cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runCommand&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;F11&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command-runner.run&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;compile&amp;run-cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runCommand&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这些设置会给你搞上这些操作: (<del>老DEVC++了</del>)</p>
<blockquote>
<p>F9 编译当前程序<br>  F10 运行当前程序<br>  F11 编译并运行  </p>
</blockquote>
<p>我按c++14,O2编译的，如果想改的话请改<code>&quot;compile-cpp&quot;</code>和<code>&quot;compile&amp;run-cpp&quot;</code>里编译器g++的参数</p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>在settings.json中:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;command-runner.commands&quot;</span> <span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;命令名称1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;命令&quot;</span><span class="punctuation">,</span></span><br><span class="line">  	<span class="comment">//你可以用[],但是它tm会在你写的每个命令后面加上逗号...</span></span><br><span class="line">	<span class="comment">//所以你先写出来要用的命令，然后用 &amp;&amp; 连接压成1行就行了</span></span><br><span class="line">  </span><br><span class="line">	<span class="attr">&quot;命令名称2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;命令&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在keybindings.json中:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一组快捷键</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;你要设的快捷键&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command-runner.run&quot;</span><span class="punctuation">,</span><span class="comment">//先调用Command Runner</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在command-runner.commands中的命令名称&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runCommand&quot;</span><span class="comment">//终端</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//想多设几个就多copy几遍</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>矩阵运算板子</title>
    <url>/2022/06/05/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>声明一个矩阵: <code>matrix a;</code></p>
<p>支持 <code>+</code> , <code>-</code> , <code>*</code> , <code>%</code> , 下标访问和快速幂.</p>
<p><strong>注意</strong>：为了方便debug，在不满足运算法则进行运算时会直接退出程序并输出 <code>Matrix error!</code></p>
<p>默认矩阵大小为 <code>Xsize</code> , <code>Ysize</code> ，可自行修改<br>我也写了构造函数，可以用 <code>matrix a(10,10)</code> 来手动规定矩形的长和宽.</p>
<p>默认情况下矩阵内全为0，可以通过下标访问修改矩阵内元素的值.</p>
<p>默认情况下矩阵内元素类型为 <code>int</code> ，可以修改 <code>#define type int</code> 来修改元素类型.</p>
<p>默认情况下矩阵自动对 <code>INT_MAX</code> 取模，你也可以修改这个自动模数，在 <code>const type mod = INT_MAX</code> 处可以修改.</p>
<p>为了debug方便你可以直接 <code>print(matrix)</code> 来输出一个矩阵.</p>
<p>我内部是用一个 <code>vector&lt;vector&lt;type&gt;&gt;</code> 实现的矩阵(二维数组太不灵活了)，常数有点大请见谅，但是我找不到更好的写法来实现矩阵了，如果有速度更快的办法可以私信我，我尽量更新( .</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Matrix</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> type int</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Xsize = <span class="number">80</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Ysize = <span class="number">80</span>;</span><br><span class="line">    <span class="type">const</span> type mod = INT_MAX;    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;type&gt;&gt; a;</span><br><span class="line">        <span class="type">int</span> xlen, ylen;</span><br><span class="line">        <span class="built_in">matrix</span>(<span class="type">int</span> x=Xsize, <span class="type">int</span> y=Ysize)</span><br><span class="line">        &#123;</span><br><span class="line">            xlen = x, ylen = y;</span><br><span class="line">            a.<span class="built_in">resize</span>(x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].<span class="built_in">resize</span>(y+<span class="number">1</span>);</span><br><span class="line">                a[i].<span class="built_in">assign</span>(y+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;type&gt;&amp; <span class="keyword">operator</span> [] (<span class="type">int</span> x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">throw_error</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Matrix error!&quot;</span>;</span><br><span class="line">        std::<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> + (matrix a, matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.xlen != b.xlen <span class="keyword">or</span> a.ylen != b.ylen)</span><br><span class="line">            <span class="built_in">throw_error</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.ylen; j++)</span><br><span class="line">            (a[i][j] += b[i][j]) %= mod;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> - (matrix a, matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.xlen != b.xlen <span class="keyword">or</span> a.ylen != b.ylen)</span><br><span class="line">            <span class="built_in">throw_error</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.ylen; j++)</span><br><span class="line">            (a[i][j] -= b[i][j]) %= mod;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (matrix a, matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.ylen != b.xlen) <span class="built_in">throw_error</span>();</span><br><span class="line">        <span class="function">matrix <span class="title">ans</span><span class="params">(a.xlen, b.ylen)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.ylen; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= a.ylen; k++)</span><br><span class="line">            (ans[i][j] += a[i][k]*b[k][j]) %= mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> * (matrix a, type k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.ylen; j++)</span><br><span class="line">            (a[i][j] *= k) %= mod;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix <span class="keyword">operator</span> % (matrix a, type k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.ylen; j++)</span><br><span class="line">            a[i][j] %= k;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span> += (matrix &amp;a, matrix b)&#123; <span class="built_in">return</span> (a = a+b); &#125;</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span> -= (matrix &amp;a, matrix b)&#123; <span class="built_in">return</span> (a = a-b); &#125;</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span> *= (matrix &amp;a, matrix b)&#123; <span class="built_in">return</span> (a = a*b); &#125;</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span> *= (matrix &amp;a, type k)&#123; <span class="built_in">return</span> (a = a*k); &#125;</span><br><span class="line">    matrix&amp; <span class="keyword">operator</span> %= (matrix &amp;a, type k)&#123; <span class="built_in">return</span> (a = a%k); &#125;</span><br><span class="line">    <span class="function">matrix <span class="title">pow</span><span class="params">(matrix a, <span class="type">long</span> <span class="type">long</span> p, type k=mod)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.xlen != a.ylen) <span class="built_in">throw_error</span>();</span><br><span class="line">        <span class="function">matrix <span class="title">ans</span><span class="params">(a.xlen, a.ylen)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">            ans[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, (a *= a) %= k)</span><br><span class="line">            <span class="keyword">if</span>(p&amp;<span class="number">1</span>) (ans *= a) %= k;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(matrix a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.xlen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.ylen; j++)</span><br><span class="line">                cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Matrix;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2022/06/07/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="关于网络流"><a href="#关于网络流" class="headerlink" title="关于网络流"></a>关于网络流</h1><p>这个东西吧，博大精深，有的题你看着像dp，或者像膜你题，但是又怎么想都想不出来，最后看算法tag发现这玩意竟然是网络流¿</p>
<p>总之就是很多看似难解、限制很多的题可以建出网络流的模型求解</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><p>网络流的模型可以抽象为水管，有一个水源，n-2个中转站，一个要送去水的目的地，每个站点都有若干个水管与其他站点相连，但是水管有粗细，每秒能通过的最大流量也不一样，求目的地每秒最多接收到多少流量。</p>
<p>其中，水管和中转站就是网，水流就是流，我们就得到了<strong>网络流</strong>。（上面求的就是源点到汇点的<strong>最大流</strong>。</p>
<p>给出一张非常经典的图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153149696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>这个图很容易看出来最大流走 <code>1-&gt;2-&gt;4</code> 和 <code>1-&gt;3-&gt;4</code> ，最大流为 $ 2 $。</p>
<p>对于程序实现，我们只知道边的最大流量还不行，还得知道现在这条边能再增加多少流量，即剩下的流量，这个剩下的流量就叫做 <strong>残量</strong>，由边的残量构成的图就叫 <strong>残量图</strong>，如果残量为 $ 0 $，那么就相当于一条断边。</p>
<p>在<strong>残量图</strong>上，如果我们从源点开始沿着某一条路径到达了汇点，说明这一条路上的流量还可以增加，我们就把这条路叫做 <strong>增广路</strong>。</p>
<p>如上图，我们可以从 $ 1 $ 开始 dfs，假设我们 dfs 到的结果是 <code>1-&gt;2-&gt;3-&gt;4</code> ，我们就得到了这条增广路，将其每条边都减去流量 $ 1 $ ，我们就得到了一个残量图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153214348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>但是此时已经没有增广路了，跟我们预期的结果不一样，我们发现，是因为程序走了 <code>2-&gt;3</code> 这条边抢了其他增广路的流量，我们怎么解决这个问题呢？有两个方法：</p>
<ol>
<li><p>写个AI，深度学习一手，拿个数据生成器就往AI里跑，然后调AI，最后调成不会走错误路线的超级AI，<del>自动暴切网络流</del></p>
</li>
<li><p>考虑实际情况，我们是OI选手，我们需要一个在考场上能用的解决方案，所以我们需要让程序在走错边时可以反悔，但又不能仅仅只是反悔，因为上图中 <code>3-&gt;4</code> 也是答案的一部分，如果走错边就反悔的话会 T 飞，我们得想办法只把 <code>2-&gt;3</code> 这条边反悔，这时就需要引入反向边了。</p>
</li>
</ol>
<p>首先，这个反向边不只是单单建个边就完事了，我们的目的是让程序反悔，让程序跑到 $ 3 $ 时再跑回 $ 2 $ 让错误路径中 <code>2-&gt;3</code> 这部分浪费掉的流量给要回来，所以我们这么处理反向边：</p>
<p>设原边的最大容量为 <code>maxflow</code> , 正边的残量为 <code>flow</code> ，反边的残量为 <code>rflow</code> ，则有 <code>flow + rflow = maxflow</code> ，通俗来讲就是把正边流走的流量加到反边上去而不是直接消失，正反边的流量和为原最大容量</p>
<p>设某一条增广路的流量为 $ a $，则对于这条增广路上的每个边，都有 <code>flow -= a</code> ， <code>rflow += a</code> ，感性理解一下，这条反向边就是为了防止走错，把正向边走的流量转移到反向边上去，再走反向边时就相当于反悔</p>
<p>我们有了反向边之后，上面那张图就变成了这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153311756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>对这个图继续寻找增广路，我们就可以找到 <code>1-&gt;3-&gt;2-&gt;4</code> 这条增广路，最终答案为 $ 2 $，与正确答案一样。</p>
<p>为什么这样就是对的呢？因为作了反向边处理之后，我们没走 <code>2-&gt;3</code> 这条路，分析一下这两条增广路：<code>1-&gt;2-&gt;3-&gt;4</code>， <code>1-&gt;3-&gt;2-&gt;4</code> ，我们把每一条边都拆出来，发现走了一个 <code>2-&gt;3</code> 和一个 <code>3-&gt;2</code> ，就相当于没走，把剩下的边拼一块，我们就得到了 <code>1-&gt;2-&gt;4</code> 和 <code>1-&gt;3-&gt;4</code> ，即得到了正确答案</p>
<p>有一条很显然的结论：当网络图中没有增广路时，此时的流就是最大流</p>
<p>证明吧…大概就是没有增广路之后我们无法反悔任何一条边来获取更大流量，所以已经是最大流了</p>
<p>严谨的证明请自己去bdfs论文，我太菜了只能这么解释XD</p>
<p>这里的反向边的实现不需要很复杂，我们可以利用成对边的思想，将链式前向星中数组下标从2开始，这样 <code>i^1</code> 就可以得到与 <code>i</code> 成对的那条边，即反边</p>
<p><strong>以下的代码都里用S和T代表源点和汇点</strong></p>
<h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>但是有了反向边又有了一个问题：我们需要保证程序不犯傻，别走了 <code>1-&gt;2</code> 再走 <code>2-&gt;1</code> 搁这原地tp。解决办法也很简单，我们可以进行bfs，走过的点标记一遍，保证不会反着走，并计算流量和前驱，直到走到汇点或者图上无增广路为止。</p>
<p>这个每次bfs找一条增广路进行增广的算法就是<em>Edmonds-Karp</em>(EK)算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> from, to, flow, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;from, to, flow, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;to, from, <span class="number">0</span>, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">int</span> dis[N], pre[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">EK</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, f;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">EK</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">graph::EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = LLONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, (ll)side[pre[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            side[pre[x]].flow -= minf;</span><br><span class="line">            side[pre[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += minf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::bfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !dis[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                pre[side[i].to] = i;</span><br><span class="line">                q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                <span class="keyword">if</span>(side[i].to == T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>EK算法的最坏时间复杂度为 $ O(nm^2) $，但一般使用达不到这个上界，大概能解决 $ 10^4 $ 级别的网络</p>
<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>但是我们发现，EK算法每次bfs最坏要遍历一遍整个图，最终却只找到一条最短增广路，这样效率很低，有很大优化空间</p>
<p>我们每次bfs时，其实可以计算出 $ [1,m] $ 条增广路，我们可以用dfs进行多路增广</p>
<p>具体方法是：每次bfs时计算出图上每个点的深度，然后从源点开始dfs，按着深度进行增广，把当前计算出的增广路全部增广掉</p>
<p>其实就是计算出深度，从源点开始灌水，把能灌的路径灌完再进行下一次bfs，这样我们可以大大减少bfs遍历图的次数，提高不少效率</p>
<p>这样每次一个bfs和一个dfs进行多路增广的就是<em>Dinic</em>算法 </p>
<p>当然最坏情况的时间复杂度也是 $ O(nm^2) $，但是实际应用的话能解决 $ 10^4,10^5 $ 级别的网络</p>
<h3 id="当前弧优化"><a href="#当前弧优化" class="headerlink" title="当前弧优化"></a>当前弧优化</h3><p>我们可以加一个<strong>小小的优化</strong>，把最坏时间复杂度从 $ O(nm^2) $ 优化成 $ O(n^2m) $</p>
<p>为了优化，我们引入几个之前就该先引入的概念，但是因为这个对于前面的理解帮助不大，所以在这里才说</p>
<p>弧：其实就是一条路径<br>弧流量：这个弧上的流量，即弧上最小边的容量</p>
<p>为什么叫当前弧优化呢，我们回顾dinic的dfs，我们就相当于从源点疯狂灌水，把能灌过去的全灌的，所以之前灌过一次的地方，它的流量一定是被”榨干”的，下次再灌的时候直接跳过即可</p>
<p>具体做法就是定义一个当前弧数组 <code>cur</code> ，在每次bfs时将 <code>head</code> copy一份到 <code>cur</code> 中，然后在dfs里每次记录下在哪条边上跳出循环，把编号赋给 <code>cur</code> ，每次遍历一个点时就从 <code>cur</code> 开始而不是 <code>head</code></p>
<p>但是这里要注意，当前弧是只针对一个分层图进行优化的，当dfs结束重新分层时，要重置 <code>cur</code> 数组</p>
<p>这样顶多遍历一遍每个点而不是每条边，成功把复杂度优化到 $ O(n^2m) $</p>
<p>dinic算法效率已经很高了，除了luogu上那个预流推进的模板题目前没找到卡dinic的题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to, flow, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">int</span> cur[N], dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, f;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dinic</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(S, T))</span><br><span class="line">        flow += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::bfs</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !dis[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                <span class="keyword">if</span>(side[i].to == T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    ll rest = flow, k; <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] == dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, (ll)side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(!k) dis[side[i].to] = <span class="number">-1</span>;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest-=k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[x] = i;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><p>割的定义：在网络流中，设源点为 $ s $，汇点为 $ t $，所有点的总集为 $ V $，将图中点分成两个集合 $ S,T $， $ s \in S $，$ t \in T $，且 $ S \cup T = V $，称其为割</p>
<p>割的容量：所有两端的点不属于同一个集合的边的容量的总和，就是割掉的边的容量和</p>
<p>求最小割就是求最小的割的容量</p>
<p>这里有一条定理：<strong>任意一个割大于等于任意一个流</strong>，我们来证一下：</p>
<blockquote>
<p>我不会那种非常严谨、语言非常规范的证明，所以我们回到开头那个比喻，首先，一个割肯定要把所有水流切断，否则 $ s $ 和 $ t $ 就是联通的，水流一定小于等于水管能承载的流量，而割的容量又等于水管的容量，所以流一定小于等于割</p>
</blockquote>
<p>有了这个定理，我们就可以得到： <strong>最小割等于最大流</strong></p>
<p>最小割通常适用于选择有冲突时求出最小花费或最大取值一类的题</p>
<p>代码就不给了，就是最大流代码</p>
<p>最小割的题大多数是给定一些比较恶心的限制然后让你求出一个选择方案使得选择的价值最大，一般这种题用最大流很难建出来模型，这时我们就可以正难则反，我们假设先把所有的都选上，然后删去冲突的方案，删去最小的就相当于求最大的，最后建最小割模型就简单多了</p>
<h1 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h1><p>为了解决更多的问题，边上多加一个权值 <code>cost</code> ，代表单位流量的花费，然后我们不仅要求出最大流，还要求出最大流状态下的最小总费用</p>
<p>首先，我们知道，在一条增广路上，整条增广路的流量由路径上残量最小的边决定，整条增广路的流量都是 <code>min(flow)</code> ，所以这条增广路的费用就是 <code>sum(dis)*min(flow)</code> 。</p>
<p>因为最大流的流量唯一，但方法不一定唯一，所以我们可以贪心一手，每次先处理出来最短路，在最短路上找增广路，一直增广到图不连通，这样我们找到的最大流一定是费用最小的。</p>
<p>这里注意反向边的处理，因为我们反向边是用来反悔的，走了反向边就相当于回退原边的流量，原边的费用肯定也要回退 (<del>rnm，退钱</del>) ，所以反向边的费用应该是 <code>-cost</code></p>
<p>因为反边的存在，我们需要能处理负边权的最短路算法，于是SPFA又在网络流里活了，一般题SPFA都是能过的</p>
<p>所以我们把最大流的bfs换成SPFA就可以得到最小费用最大流的算法了，用SPFA+EK或SPFA+dinic都可以，这里注意dinic中的dfs要标记走过的点，不要在 <code>cost=0</code> 的边上转圈.</p>
<p>SPFA+EK 代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> from, to, flow, cost, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> flow, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;from, to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;to, from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">int</span> pre[N];</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">EK</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">EK</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = LLONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, (ll)side[pre[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            side[pre[x]].flow -= minf;</span><br><span class="line">            side[pre[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += minf;</span><br><span class="line">        mincost += minf*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;maxflow, mincost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost;</span><br><span class="line">                pre[side[i].to] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SPFA+Dinic 代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to, flow, cost, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> flow, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="type">int</span> cur[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">dinic</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll k = <span class="built_in">dfs</span>(S, inf);</span><br><span class="line">        maxflow += k;</span><br><span class="line">        mincost += k*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;maxflow, mincost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    ll rest = flow, k; <span class="type">int</span> i;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !vis[side[i].to] <span class="keyword">and</span> dis[side[i].to] == dis[x]+side[i].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, (ll)side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) dis[side[i].to] = LLONG_MAX;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest -= k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cur[x] = i, flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zkw费用流"><a href="#zkw费用流" class="headerlink" title="zkw费用流"></a>zkw费用流</h2><p>上面的算法在每次SPFA处理出源点到其它点的最短路后进行增广，但是这样可能会进入一些根本不会到达汇点的分支，浪费很多时间，我们可以优化一下</p>
<p>想一个问题：给一个无向图，求S到T的所有路径并把路径都打上标记</p>
<p>这个问题我们可以分别从S和T进行bfs，被标记两次的边就一定是从S到T的路径上的边</p>
<p>我们可以按照这个思想来进行增广，所以我们从T向S跑最短路，然后从S向T增广流量，这样增广的边就一定是从S到T的路径上的边</p>
<p>这里注意从T到S跑SPFA时我们遍历到的边都是反边，需要通过<code>i^1</code>取出原来的正边的流量和费用，增广时判费用要用减法，具体可以看代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to, flow, cost, next;</span><br><span class="line">    &#125;side[M];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> flow, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="type">int</span> cur[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">dinic</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll k = <span class="built_in">dfs</span>(S, inf);</span><br><span class="line">        flow += k;</span><br><span class="line">        cost += k*dis[S];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(T); dis[T] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i^<span class="number">1</span>].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i^<span class="number">1</span>].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i^<span class="number">1</span>].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[S] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="type">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> rest = flow, k, i;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !vis[side[i].to] <span class="keyword">and</span> dis[side[i].to] == dis[x]-side[i].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) dis[side[i].to] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest -= k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cur[x] = i, flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Primal-Dual原始对偶"><a href="#Primal-Dual原始对偶" class="headerlink" title="Primal-Dual原始对偶"></a>Primal-Dual原始对偶</h2><p>这个坑我先开了，以后再填(偷懒</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pint pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        ll flow, cost;</span><br><span class="line">        <span class="type">int</span> next;</span><br><span class="line">    &#125;side[M];</span><br><span class="line">    <span class="type">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, ll flow, ll cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> S, T;</span><br><span class="line">    <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="type">int</span> pres[N], prex[N];</span><br><span class="line">    ll dis[N], h[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">MCMF</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">MCMF</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">dijkstra</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            h[i] += dis[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = prex[x])</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, side[pres[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = T; x != S; x = prex[x])</span><br><span class="line">        &#123;</span><br><span class="line">            side[pres[x]].flow -= minf;</span><br><span class="line">            side[pres[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += minf;</span><br><span class="line">        cost += h[T]*minf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">graph::spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> h[side[i].to] &gt; h[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                h[side[i].to] = h[x]+side[i].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id; ll dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)</span><br><span class="line">&#123; <span class="keyword">return</span> a.dis &gt; b.dis; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">graph::dijkstra</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>&#125;); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">top</span>().id; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>; vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost+h[x]-h[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost+h[x]-h[side[i].to];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;side[i].to, dis[side[i].to]&#125;);</span><br><span class="line">                pres[side[i].to] = i; prex[side[i].to] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h1><p>以网络流的特性来看，肯定能很容易地解决二分图匹配问题，因为限制流量就可以限制每个点的匹配数、被匹配数，多重匹配问题也随之解决</p>
<p>对于二分图带权最大匹配更简单了，直接权值取负数跑最小费用最大流，再对费用取反就可以直接解决二分图带权匹配问题</p>
<p>当然费用流对于二分图最大完美匹配的问题的处理速度还是不如KM算法的，但你可以通过极致卡常过掉 <a href="https://www.luogu.com.cn/problem/P6577">    P6577</a></p>
<h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><p>为了解决亿些更复杂的问题，光是有流量上限还不行，每个边的流量都有一个上界和下界，求是否存在一个流可以满足所有边的上下界和所有点流量平衡</p>
<p>首先这个下界很烦，有这个下界我们就很难套上面的板子，于是我们想办法把这个下界消掉</p>
<p>我们可以先满足所有边的下界，这样每条边就只剩下一个 <code>r-l</code> 的上界了，可以扔到普通网络流的板子里</p>
<p>但是这样又诞生了许多问题，首先满足下界之后势必会有一些点不满足流量平衡，一些点存了流量，一些点透支了流量，我们设每个点所存的流量为 <code>val</code> ，即流入量减去流出量</p>
<p>我们需要在满足上界的条件下，把存下的流量推送给透支的流量上，达到满足流量平衡</p>
<p>于是我们得想办法让一股流从多的点流到少的点，但我们又不能凭空造流，否则不满足流量平衡，于是我们需要建一个虚拟源点汇点，因为最大流中源点汇点可以不满足流量平衡</p>
<p>所以对于 <code>val&gt;0</code> 的点，我们从 <code>S</code> 向它建一条流量为<code>val</code>的边，对于 <code>val&lt;0</code> 的点，我们从它向 <code>T</code> 建一条流量为 <code>-val</code> 的边，然后跑最大流，这样我们所有存下的流量就可以流到透支的地方去了</p>
<p>设所有存下的流量为 <code>sum</code> ，即 $ \Sigma val_i[val_i&gt;0] $，如果跑出来的流量等于 <code>sum</code> 的话，证明可以平衡掉所有的流量，即存在可行流，如果小于 <code>sum</code> 的话证明没有可行流</p>
<p>Code: <a href=".\Code\无源汇上下界可行流.cpp">无源汇上下界可行流</a></p>
<h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>这个问题多了源汇，因为源汇是不需要满足流量平衡的，所以没法直接跑出可行流</p>
<p>以下部分用<code>S</code>和<code>T</code>代表虚拟源点汇点(跑网络流实际要用的)，<code>s</code>和<code>t</code>代表题目中实际的源点和汇点</p>
<p>这时候我们就可以从 <code>t-&gt;s</code> 建一条流量为 <code>inf</code> 的边，直接转化为无源汇问题，我们跑无源汇上下界可行流即可</p>
<p>但是直接跑的话可能没有达到最大流量，因为我们只满足了下界</p>
<p>但是我们已经满足下界了，就相当于没有了下界这个条件，这时再跑一次 <code>s-&gt;t</code> 的最大流，加到答案中，就是有源汇上下界最大流的答案了</p>
<p>因为跑出可行流之后已经满足了流量平衡，这时跑最大流除了 <code>s</code> 和 <code>t</code> 也是都满足流量平衡的，然后最大流会把能跑的流量全跑完，所以就可以求出答案来</p>
<p>这里要特别注意一定要删去之前建的 <code>t-&gt;s</code> 的边，否则就是一个死循环打到你脸上</p>
<p>Code: <a href=".\Code\有源汇上下界最大流.cpp">有源汇上下界最大流</a></p>
<h2 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h2><p>其实跟上面差不多，最小流不就是尽量让流变小吗，我们可以先跑出可行流，然后从 <code>t-&gt;s</code> 跑一边最大流(感性理解)，减去跑出的流量，就是最小流的答案</p>
<p>就是从 <code>t-&gt;s</code> 能退回去多少就退回去多少流</p>
<h2 id="有费用的上下界网络流"><a href="#有费用的上下界网络流" class="headerlink" title="有费用的上下界网络流"></a>有费用的上下界网络流</h2><p>其实就是套个费用流，注意跑最小流的时候费用也是累加而不是减去第二部分的费用(退流时走的反边已经有退回费用的功能了)</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这里是我找的一些题，题单前半部分都是水题(锻炼敲板子和基础建模能力)，后半部分有一些稍微有难度的题，可以好好想一下</p>
<p><a href="https://www.luogu.com.cn/training/172988">题单链接</a></p>
<p>经典的网络流24题，有些题还是很不错的</p>
<p><a href="https://www.luogu.com.cn/problem/list?tag=332&amp;page=1&amp;orderBy=difficulty&amp;order=asc">网络流24题</a></p>
<h1 id="引用的一些资料"><a href="#引用的一些资料" class="headerlink" title="引用的一些资料"></a>引用的一些资料</h1><p><a href="https://www.cnblogs.com/victorique/p/8560656.html">网络流建模</a><br>w</p>
]]></content>
      <categories>
        <category>课件</category>
      </categories>
  </entry>
  <entry>
    <title>高精板子</title>
    <url>/2022/06/05/%E9%AB%98%E7%B2%BE%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>支持除位运算符外所有运算符，请通过修改<code>bigint_SIZE</code>来修改高精数长度</p>
<p>tips: 除法有一点慢</p>
<p>输入输出可以用成员函数<code>(bigint).input()</code>和<code>(bigint).print()</code>，也可以用<code>read(bigint&amp;)</code>和<code>print(bigint)</code></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bigint_space&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bigint_SIZE = <span class="number">505</span>;</span><br><span class="line">    <span class="type">char</span> bigint_input[bigint_SIZE];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">division_compare</span><span class="params">(<span class="type">short</span> *a, <span class="type">int</span> lena, <span class="type">short</span> *b, <span class="type">int</span> lenb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lena != lenb)</span><br><span class="line">            <span class="keyword">return</span> lena &gt; lenb;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">division_minus</span><span class="params">(<span class="type">short</span> *a, <span class="type">int</span> lena, <span class="type">short</span> *b, <span class="type">int</span> lenb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = lena != lenb;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = lena; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] -= b[i-f];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)</span><br><span class="line">                a[i] += <span class="number">10</span>, a[i<span class="number">-1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">bigint</span>&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">short</span> s[bigint_SIZE];</span><br><span class="line">            <span class="type">bool</span> less0;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">bigint</span>(<span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">                len = <span class="number">0</span>; less0 = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    len = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">                    less0 = <span class="literal">true</span>, x = -x;</span><br><span class="line">                <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">                    s[++len] = x%<span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; std::<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s)); len=<span class="number">1</span>; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                std::<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">                std::<span class="built_in">memset</span>(bigint_input, <span class="number">0</span>, <span class="built_in">sizeof</span>(bigint_input));</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">                <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        less0 = <span class="literal">true</span>;</span><br><span class="line">                    ch = <span class="built_in">getchar</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">                &#123;</span><br><span class="line">                    bigint_input[++len] = ch;</span><br><span class="line">                    ch = <span class="built_in">getchar</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">                    s[i] = bigint_input[len-i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">                <span class="meta">#<span class="keyword">ifdef</span> getchar</span></span><br><span class="line">                    ibufp1--;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(less0) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                    <span class="built_in">putchar</span>(s[i]+<span class="number">48</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> + (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                bigint c;</span><br><span class="line">                c.len = a.len &gt; b.len ? a.len : b.len;</span><br><span class="line">                <span class="keyword">if</span>(a.less0 &amp;&amp; b.less0)</span><br><span class="line">                    <span class="keyword">return</span> -(-a + -b);</span><br><span class="line">                <span class="keyword">if</span>(a.less0)</span><br><span class="line">                    <span class="keyword">return</span> b-<span class="built_in">abs</span>(a);</span><br><span class="line">                <span class="keyword">if</span>(b.less0)</span><br><span class="line">                    <span class="keyword">return</span> a-<span class="built_in">abs</span>(b);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c.len+<span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.s[i] += a.s[i]+b.s[i];</span><br><span class="line">                    c.s[i+<span class="number">1</span>] += c.s[i]/<span class="number">10</span>;</span><br><span class="line">                    c.s[i] %= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c.s[c.len+<span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">                c.len++;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> - (bigint a)</span><br><span class="line">            &#123;</span><br><span class="line">                a.less0 = !a.less0;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> - (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(b.less0)</span><br><span class="line">                    <span class="keyword">return</span> a+<span class="built_in">abs</span>(b);</span><br><span class="line">                <span class="keyword">if</span>(a.less0)</span><br><span class="line">                    <span class="keyword">return</span> -(<span class="built_in">abs</span>(a)+b);</span><br><span class="line">                <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">                    <span class="keyword">return</span> -(b-a);</span><br><span class="line">                bigint c;</span><br><span class="line">                c.len = a.len &gt; b.len ? a.len : b.len;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c.len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.s[i] = a.s[i]-b.s[i];</span><br><span class="line">                    <span class="keyword">if</span>(c.s[i] &lt; <span class="number">0</span>)</span><br><span class="line">                        a.s[i+<span class="number">1</span>]--, c.s[i] += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(c.s[c.len] == <span class="number">0</span> <span class="keyword">and</span> c.len &gt; <span class="number">1</span>)</span><br><span class="line">                    c.len--;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> * (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                bigint c;</span><br><span class="line">                c.less0 = a.less0 ^ b.less0;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b.len; i++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.len; j++)</span><br><span class="line">                        c.s[i+j<span class="number">-1</span>] += a.s[j]*b.s[i];</span><br><span class="line">                c.len = a.len+b.len;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c.len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.s[i+<span class="number">1</span>] += c.s[i]/<span class="number">10</span>;</span><br><span class="line">                    c.s[i] %= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(c.s[c.len] == <span class="number">0</span> <span class="keyword">and</span> c.len &gt; <span class="number">1</span>)</span><br><span class="line">                    c.len--;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> / (bigint a, <span class="type">long</span> <span class="type">long</span> b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                bigint c;</span><br><span class="line">                c.len = a.len;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = a.len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    tot *= <span class="number">10</span>;</span><br><span class="line">                    tot += a.s[i];</span><br><span class="line">                    <span class="keyword">if</span>(tot &gt;= b)</span><br><span class="line">                    &#123;</span><br><span class="line">                        c.s[i] = tot/b;</span><br><span class="line">                        tot %= b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(c.s[c.len] == <span class="number">0</span> <span class="keyword">and</span> c.len &gt; <span class="number">1</span>)</span><br><span class="line">                    c.len--;</span><br><span class="line">                c.less0 = a.less0 ^ (b&lt;<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> / (bigint a,bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                bigint c;</span><br><span class="line">                c.len = a.len-b.len+<span class="number">1</span>;</span><br><span class="line">                c.less0 = a.less0 ^ b.less0;</span><br><span class="line">                <span class="type">short</span> abuf[bigint_SIZE]; <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">                <span class="type">short</span> bbuf[bigint_SIZE];</span><br><span class="line">                <span class="built_in">memset</span>(abuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(abuf));</span><br><span class="line">                <span class="built_in">memset</span>(bbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(bbuf));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = b.len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                    bbuf[i] = b.s[b.len-i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = a.len; i &gt;= <span class="number">1</span>;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!<span class="built_in">division_compare</span>(abuf, top, bbuf, b.len) <span class="keyword">and</span> i &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(top == <span class="number">0</span> <span class="keyword">and</span> a.s[i] == <span class="number">0</span>))</span><br><span class="line">                            abuf[++top] = a.s[i];</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">division_compare</span>(abuf, top, bbuf, b.len))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">division_minus</span>(abuf, top, bbuf, b.len);</span><br><span class="line">                        c.s[i+<span class="number">1</span>]++;</span><br><span class="line">                        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top; j++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(abuf[j] != <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            tot++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tot != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top-tot; j++)</span><br><span class="line">                                abuf[j] = abuf[j+tot], abuf[j+tot] = <span class="number">0</span>;</span><br><span class="line">                            top -= tot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(c.s[c.len] == <span class="number">0</span> <span class="keyword">and</span> c.len &gt; <span class="number">1</span>)</span><br><span class="line">                    c.len--;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> % (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                bigint c;</span><br><span class="line">                c.less0 = <span class="number">0</span>;</span><br><span class="line">                <span class="type">short</span> abuf[bigint_SIZE]; <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">                <span class="type">short</span> bbuf[bigint_SIZE];</span><br><span class="line">                <span class="built_in">memset</span>(abuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(abuf));</span><br><span class="line">                <span class="built_in">memset</span>(bbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(bbuf));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = b.len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                    bbuf[i] = b.s[b.len-i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = a.len; i &gt;= <span class="number">1</span>;)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!<span class="built_in">division_compare</span>(abuf, top, bbuf, b.len) <span class="keyword">and</span> i &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(top == <span class="number">0</span> <span class="keyword">and</span> a.s[i] == <span class="number">0</span>))</span><br><span class="line">                            abuf[++top] = a.s[i];</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">division_compare</span>(abuf, top, bbuf, b.len))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">division_minus</span>(abuf, top, bbuf, b.len);</span><br><span class="line">                        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top; j++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(abuf[j] != <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            tot++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tot != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top-tot; j++)</span><br><span class="line">                                abuf[j] = abuf[j+tot], abuf[j+tot] = <span class="number">0</span>;</span><br><span class="line">                            top -= tot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c.len = (top==<span class="number">0</span>)?<span class="number">1</span>:top;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = top; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                    c.s[top-i+<span class="number">1</span>] = abuf[i];</span><br><span class="line">                <span class="keyword">while</span>(c.s[c.len] == <span class="number">0</span> <span class="keyword">and</span> c.len &gt; <span class="number">1</span>)</span><br><span class="line">                    c.len--;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> ++ (bigint &amp;a) &#123; <span class="keyword">return</span> (a = a+<span class="number">1</span>); &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> ++ (<span class="type">int</span>)&#123;</span><br><span class="line">                bigint a = *<span class="keyword">this</span>;</span><br><span class="line">                *<span class="keyword">this</span> = (*<span class="keyword">this</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> bigint <span class="keyword">operator</span> -- (bigint &amp;a) &#123; <span class="keyword">return</span> (a = a<span class="number">-1</span>); &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> -- (<span class="type">int</span>)&#123;</span><br><span class="line">                bigint a = *<span class="keyword">this</span>;</span><br><span class="line">                *<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> = (<span class="type">long</span> <span class="type">long</span> x)&#123;</span><br><span class="line">                std::<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">                len = <span class="number">0</span>; less0 = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    len = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">                    less0 = <span class="literal">true</span>, x = -x;</span><br><span class="line">                <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">                    s[++len] = x%<span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a.less0 != b.less0)</span><br><span class="line">                    <span class="keyword">return</span> a.less0 &lt; b.less0;</span><br><span class="line">                <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(a.len != b.len)</span><br><span class="line">                    ans = a.len &gt; b.len;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = a.len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                        <span class="keyword">if</span>(a.s[i] != b.s[i])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = a.s[i] &gt; b.s[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (a.less0 <span class="keyword">and</span> b.less0) ? !ans : ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a.less0 != b.less0)</span><br><span class="line">                    <span class="keyword">return</span> a.less0 &gt; b.less0;</span><br><span class="line">                <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(a.len != b.len)</span><br><span class="line">                    ans = a.len &lt; b.len;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = a.len ; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                        <span class="keyword">if</span>(a.s[i] != b.s[i])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = a.s[i] &lt; b.s[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (a.less0 <span class="keyword">and</span> b.less0) ? !ans : ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (bigint a, bigint b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a.less0 != b.less0)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(a.len != b.len)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.len; i++)</span><br><span class="line">                    <span class="keyword">if</span>(a.s[i] != b.s[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (bigint a, bigint b) &#123; <span class="keyword">return</span> !(a&lt;b); &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (bigint a, bigint b) &#123; <span class="keyword">return</span> !(a&gt;b); &#125;</span><br><span class="line">            <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> != (bigint a, bigint b) &#123; <span class="keyword">return</span> !(a==b); &#125;</span><br><span class="line">            <span class="function"><span class="keyword">friend</span> bigint <span class="title">max</span><span class="params">(bigint a, bigint b)</span></span>&#123; <span class="keyword">return</span> a&gt;b?a:b; &#125;</span><br><span class="line">            <span class="function"><span class="keyword">friend</span> bigint <span class="title">min</span><span class="params">(bigint a, bigint b)</span></span>&#123; <span class="keyword">return</span> a&lt;b?a:b; &#125;</span><br><span class="line">            <span class="function"><span class="keyword">friend</span> bigint <span class="title">abs</span><span class="params">(bigint a)</span></span>&#123; a.less0 = <span class="literal">false</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> += (bigint a)&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+a; &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> -= (bigint a)&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-a; &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> *= (bigint a)&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*a; &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> /= (bigint a)&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/a; &#125;</span><br><span class="line">            bigint <span class="keyword">operator</span> %= (bigint a)&#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>%a; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(bigint &amp;a)</span></span>&#123; a.<span class="built_in">input</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(bigint a)</span> </span>&#123; a.<span class="built_in">print</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bigint_space;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
</search>
