<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>网络流 | Ptilopsis_w's little blog</title><meta name="author" content="Ptilopsis_w"><meta name="copyright" content="Ptilopsis_w"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于网络流 这个东西吧，博大精深，有的题你看着像dp，或者像膜你题，但是又怎么想都想不出来，最后看算法tag发现这玩意竟然是网络流¿ 总之就是很多看似难解、限制很多的题可以建出网络流的模型求解 最大流 网络流的模型可以抽象为水管，有一个水源，n-2个中转站，一个要送去水的目的地，每个站点都有若干个水管与其他站点相连，但是水管有粗细，每秒能通过的最大流量也不一样，求目的地每秒最多接收到多少流量。 其">
<meta property="og:type" content="article">
<meta property="og:title" content="网络流">
<meta property="og:url" content="http://example.com/2022/08/09/%E7%BD%91%E7%BB%9C%E6%B5%81/index.html">
<meta property="og:site_name" content="Ptilopsis_w&#39;s little blog">
<meta property="og:description" content="关于网络流 这个东西吧，博大精深，有的题你看着像dp，或者像膜你题，但是又怎么想都想不出来，最后看算法tag发现这玩意竟然是网络流¿ 总之就是很多看似难解、限制很多的题可以建出网络流的模型求解 最大流 网络流的模型可以抽象为水管，有一个水源，n-2个中转站，一个要送去水的目的地，每个站点都有若干个水管与其他站点相连，但是水管有粗细，每秒能通过的最大流量也不一样，求目的地每秒最多接收到多少流量。 其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.328888.xyz/2022/06/07/zhRWk.jpg">
<meta property="article:published_time" content="2022-08-09T08:57:36.702Z">
<meta property="article:modified_time" content="2022-08-17T02:59:28.111Z">
<meta property="article:author" content="Ptilopsis_w">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.328888.xyz/2022/06/07/zhRWk.jpg"><link rel="shortcut icon" href="https://s1.328888.xyz/2022/06/09/zxPy7.jpg"><link rel="canonical" href="http://example.com/2022/08/09/%E7%BD%91%E7%BB%9C%E6%B5%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-17 10:59:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.328888.xyz/2022/08/03/OWtcw.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.328888.xyz/2022/06/07/zhRWk.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ptilopsis_w's little blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-09T08:57:36.702Z" title="发表于 2022-08-09 16:57:36">2022-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-17T02:59:28.111Z" title="更新于 2022-08-17 10:59:28">2022-08-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E4%BB%B6/">课件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/08/09/%E7%BD%91%E7%BB%9C%E6%B5%81/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>关于网络流</h1>
<p>这个东西吧，博大精深，有的题你看着像dp，或者像膜你题，但是又怎么想都想不出来，最后看算法tag发现这玩意竟然是网络流¿</p>
<p>总之就是很多看似难解、限制很多的题可以建出网络流的模型求解</p>
<h1>最大流</h1>
<p>网络流的模型可以抽象为水管，有一个水源，n-2个中转站，一个要送去水的目的地，每个站点都有若干个水管与其他站点相连，但是水管有粗细，每秒能通过的最大流量也不一样，求目的地每秒最多接收到多少流量。</p>
<p>其中，水管和中转站就是网，水流就是流，我们就得到了<strong>网络流</strong>。（上面求的就是源点到汇点的<strong>最大流</strong>。</p>
<p>给出一张非常经典的图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153149696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>这个图很容易看出来最大流走 <code>1-&gt;2-&gt;4</code> 和 <code>1-&gt;3-&gt;4</code> ，最大流为 $ 2 $。</p>
<p>对于程序实现，我们只知道边的最大流量还不行，还得知道现在这条边能再增加多少流量，即剩下的流量，这个剩下的流量就叫做 <strong>残量</strong>，由边的残量构成的图就叫 <strong>残量图</strong>，如果残量为 $ 0 $，那么就相当于一条断边。</p>
<p>在<strong>残量图</strong>上，如果我们从源点开始沿着某一条路径到达了汇点，说明这一条路上的流量还可以增加，我们就把这条路叫做 <strong>增广路</strong>。</p>
<p>如上图，我们可以从 $ 1 $ 开始 dfs，假设我们 dfs 到的结果是 <code>1-&gt;2-&gt;3-&gt;4</code> ，我们就得到了这条增广路，将其每条边都减去流量 $ 1 $ ，我们就得到了一个残量图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153214348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>但是此时已经没有增广路了，跟我们预期的结果不一样，我们发现，是因为程序走了 <code>2-&gt;3</code> 这条边抢了其他增广路的流量，我们怎么解决这个问题呢？有两个方法：</p>
<ol>
<li>
<p>写个AI，深度学习一手，拿个数据生成器就往AI里跑，然后调AI，最后调成不会走错误路线的超级AI，<s>自动暴切网络流</s></p>
</li>
<li>
<p>考虑实际情况，我们是OI选手，我们需要一个在考场上能用的解决方案，所以我们需要让程序在走错边时可以反悔，但又不能仅仅只是反悔，因为上图中 <code>3-&gt;4</code> 也是答案的一部分，如果走错边就反悔的话会 T 飞，我们得想办法只把 <code>2-&gt;3</code> 这条边反悔，这时就需要引入反向边了。</p>
</li>
</ol>
<p>首先，这个反向边不只是单单建个边就完事了，我们的目的是让程序反悔，让程序跑到 $ 3 $ 时再跑回 $ 2 $ 让错误路径中 <code>2-&gt;3</code> 这部分浪费掉的流量给要回来，所以我们这么处理反向边：</p>
<p>设原边的最大容量为 <code>maxflow</code> , 正边的残量为 <code>flow</code> ，反边的残量为 <code>rflow</code> ，则有 <code>flow + rflow = maxflow</code> ，通俗来讲就是把正边流走的流量加到反边上去而不是直接消失，正反边的流量和为原最大容量</p>
<p>设某一条增广路的流量为 $ a $，则对于这条增广路上的每个边，都有 <code>flow -= a</code> ， <code>rflow += a</code> ，感性理解一下，这条反向边就是为了防止走错，把正向边走的流量转移到反向边上去，再走反向边时就相当于反悔</p>
<p>我们有了反向边之后，上面那张图就变成了这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20190730153311756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzgwMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>对这个图继续寻找增广路，我们就可以找到 <code>1-&gt;3-&gt;2-&gt;4</code> 这条增广路，最终答案为 $ 2 $，与正确答案一样。</p>
<p>为什么这样就是对的呢？因为作了反向边处理之后，我们没走 <code>2-&gt;3</code> 这条路，分析一下这两条增广路：<code>1-&gt;2-&gt;3-&gt;4</code>， <code>1-&gt;3-&gt;2-&gt;4</code> ，我们把每一条边都拆出来，发现走了一个 <code>2-&gt;3</code> 和一个 <code>3-&gt;2</code> ，就相当于没走，把剩下的边拼一块，我们就得到了 <code>1-&gt;2-&gt;4</code> 和 <code>1-&gt;3-&gt;4</code> ，即得到了正确答案</p>
<p>有一条很显然的结论：当网络图中没有增广路时，此时的流就是最大流</p>
<p>证明吧…大概就是没有增广路之后我们无法反悔任何一条边来获取更大流量，所以已经是最大流了</p>
<p>严谨的证明请自己去bdfs论文，我太菜了只能这么解释XD</p>
<p>这里的反向边的实现不需要很复杂，我们可以利用成对边的思想，将链式前向星中数组下标从2开始，这样 <code>i^1</code> 就可以得到与 <code>i</code> 成对的那条边，即反边</p>
<p><strong>以下的代码都里用S和T代表源点和汇点</strong></p>
<h2 id="Edmonds-Karp算法">Edmonds-Karp算法</h2>
<p>但是有了反向边又有了一个问题：我们需要保证程序不犯傻，别走了 <code>1-&gt;2</code> 再走 <code>2-&gt;1</code> 搁这原地tp。解决办法也很简单，我们可以进行bfs，走过的点标记一遍，保证不会反着走，并计算流量和前驱，直到走到汇点或者图上无增广路为止。</p>
<p>这个每次bfs找一条增广路进行增广的算法就是<em>Edmonds-Karp</em>(EK)算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, flow, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;from, to, flow, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;to, from, <span class="number">0</span>, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">int</span> dis[N], pre[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">EK</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, f;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">EK</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">graph::EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = LLONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, (ll)side[pre[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            side[pre[x]].flow -= minf;</span><br><span class="line">            side[pre[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += minf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !dis[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                pre[side[i].to] = i;</span><br><span class="line">                q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                <span class="keyword">if</span>(side[i].to == T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>EK算法的最坏时间复杂度为 $ O(nm^2) $，但一般使用达不到这个上界，大概能解决 $ 10^4 $ 级别的网络</p>
<h2 id="Dinic算法">Dinic算法</h2>
<p>但是我们发现，EK算法每次bfs最坏要遍历一遍整个图，最终却只找到一条最短增广路，这样效率很低，有很大优化空间</p>
<p>我们每次bfs时，其实可以计算出 $ [1,m] $ 条增广路，我们可以用dfs进行多路增广</p>
<p>具体方法是：每次bfs时计算出图上每个点的深度，然后从源点开始dfs，按着深度进行增广，把当前计算出的增广路全部增广掉</p>
<p>其实就是计算出深度，从源点开始灌水，把能灌的路径灌完再进行下一次bfs，这样我们可以大大减少bfs遍历图的次数，提高不少效率</p>
<p>这样每次一个bfs和一个dfs进行多路增广的就是<em>Dinic</em>算法</p>
<p>当然最坏情况的时间复杂度也是 $ O(nm^2) $，但是实际应用的话能解决 $ 10^4,10^5 $ 级别的网络</p>
<h3 id="当前弧优化">当前弧优化</h3>
<p>我们可以加一个<strong>小小的优化</strong>，把最坏时间复杂度从 $ O(nm^2) $ 优化成 $ O(n^2m) $</p>
<p>为了优化，我们引入几个之前就该先引入的概念，但是因为这个对于前面的理解帮助不大，所以在这里才说</p>
<p>弧：其实就是一条路径<br>
弧流量：这个弧上的流量，即弧上最小边的容量</p>
<p>为什么叫当前弧优化呢，我们回顾dinic的dfs，我们就相当于从源点疯狂灌水，把能灌过去的全灌的，所以之前灌过一次的地方，它的流量一定是被&quot;榨干&quot;的，下次再灌的时候直接跳过即可</p>
<p>具体做法就是定义一个当前弧数组 <code>cur</code> ，在每次bfs时将 <code>head</code> copy一份到 <code>cur</code> 中，然后在dfs里每次记录下在哪条边上跳出循环，把编号赋给 <code>cur</code> ，每次遍历一个点时就从 <code>cur</code> 开始而不是 <code>head</code></p>
<p>但是这里要注意，当前弧是只针对一个分层图进行优化的，当dfs结束重新分层时，要重置 <code>cur</code> 数组</p>
<p>这样顶多遍历一遍每个点而不是每条边，成功把复杂度优化到 $ O(n^2m) $</p>
<p>dinic算法效率已经很高了，除了luogu上那个预流推进的模板题目前没找到卡dinic的题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, flow, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">int</span> cur[N], dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, f;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dinic</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(S, T))</span><br><span class="line">        flow += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::bfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !dis[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                <span class="keyword">if</span>(side[i].to == T)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    ll rest = flow, k; <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] == dis[x]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, (ll)side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(!k) dis[side[i].to] = <span class="number">-1</span>;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest-=k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[x] = i;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>最小割</h1>
<p>割的定义：在网络流中，设源点为 $ s $，汇点为 $ t $，所有点的总集为 $ V $，将图中点分成两个集合 $ S,T $， $ s \in S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext></mrow><annotation encoding="application/x-tex">，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">，</span></span></span></span> t \in T $，且 $ S \cup T = V $，称其为割</p>
<p>割的容量：所有两端的点不属于同一个集合的边的容量的总和，就是割掉的边的容量和</p>
<p>求最小割就是求最小的割的容量</p>
<p>这里有一条定理：<strong>任意一个割大于等于任意一个流</strong>，我们来证一下：</p>
<blockquote>
<p>我不会那种非常严谨、语言非常规范的证明，所以我们回到开头那个比喻，首先，一个割肯定要把所有水流切断，否则 $ s $ 和 $ t $ 就是联通的，水流一定小于等于水管能承载的流量，而割的容量又等于水管的容量，所以流一定小于等于割</p>
</blockquote>
<p>有了这个定理，我们就可以得到： <strong>最小割等于最大流</strong></p>
<p>最小割通常适用于选择有冲突时求出最小花费或最大取值一类的题</p>
<p>代码就不给了，就是最大流代码</p>
<p>最小割的题大多数是给定一些比较恶心的限制然后让你求出一个选择方案使得选择的价值最大，一般这种题用最大流很难建出来模型，这时我们就可以正难则反，我们假设先把所有的都选上，然后删去冲突的方案，删去最小的就相当于求最大的，最后建最小割模型就简单多了</p>
<h1>最小费用最大流</h1>
<p>为了解决更多的问题，边上多加一个权值 <code>cost</code> ，代表单位流量的花费，然后我们不仅要求出最大流，还要求出最大流状态下的最小总费用</p>
<p>首先，我们知道，在一条增广路上，整条增广路的流量由路径上残量最小的边决定，整条增广路的流量都是 <code>min(flow)</code> ，所以这条增广路的费用就是 <code>sum(dis)*min(flow)</code> 。</p>
<p>因为最大流的流量唯一，但方法不一定唯一，所以我们可以贪心一手，每次先处理出来最短路，在最短路上找增广路，一直增广到图不连通，这样我们找到的最大流一定是费用最小的。</p>
<p>这里注意反向边的处理，因为我们反向边是用来反悔的，走了反向边就相当于回退原边的流量，原边的费用肯定也要回退 (<s>rnm，退钱</s>) ，所以反向边的费用应该是 <code>-cost</code></p>
<p>因为反边的存在，我们需要能处理负边权的最短路算法，于是SPFA又在网络流里活了，一般题SPFA都是能过的</p>
<p>所以我们把最大流的bfs换成SPFA就可以得到最小费用最大流的算法了，用SPFA+EK或SPFA+dinic都可以，这里注意dinic中的dfs要标记走过的点，不要在 <code>cost=0</code> 的边上转圈.</p>
<p>SPFA+EK 代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> from, to, flow, cost, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> flow, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;from, to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;to, from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">int</span> pre[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">EK</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">EK</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = LLONG_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, (ll)side[pre[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = side[pre[x]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            side[pre[x]].flow -= minf;</span><br><span class="line">            side[pre[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += minf;</span><br><span class="line">        mincost += minf*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;maxflow, mincost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost;</span><br><span class="line">                pre[side[i].to] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SPFA+Dinic 代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, flow, cost, next;</span><br><span class="line">    &#125;side[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> flow, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="keyword">int</span> cur[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">dinic</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll k = <span class="built_in">dfs</span>(S, inf);</span><br><span class="line">        maxflow += k;</span><br><span class="line">        mincost += k*dis[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;maxflow, mincost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    ll rest = flow, k; <span class="keyword">int</span> i;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !vis[side[i].to] <span class="keyword">and</span> dis[side[i].to] == dis[x]+side[i].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, (ll)side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) dis[side[i].to] = LLONG_MAX;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest -= k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cur[x] = i, flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zkw费用流">zkw费用流</h2>
<p>上面的算法在每次SPFA处理出源点到其它点的最短路后进行增广，但是这样可能会进入一些根本不会到达汇点的分支，浪费很多时间，我们可以优化一下</p>
<p>想一个问题：给一个无向图，求S到T的所有路径并把路径都打上标记</p>
<p>这个问题我们可以分别从S和T进行bfs，被标记两次的边就一定是从S到T的路径上的边</p>
<p>我们可以按照这个思想来进行增广，所以我们从T向S跑最短路，然后从S向T增广流量，这样增广的边就一定是从S到T的路径上的边</p>
<p>这里注意从T到S跑SPFA时我们遍历到的边都是反边，需要通过<code>i^1</code>取出原来的正边的流量和费用，增广时判费用要用减法，具体可以看代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, flow, cost, next;</span><br><span class="line">    &#125;side[M];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> flow, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="keyword">int</span> cur[N];</span><br><span class="line">    ll dis[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">dinic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">    <span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">dinic</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll k = <span class="built_in">dfs</span>(S, inf);</span><br><span class="line">        flow += k;</span><br><span class="line">        cost += k*dis[S];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::spfa</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    q.<span class="built_in">push</span>(T); dis[T] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i^<span class="number">1</span>].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i^<span class="number">1</span>].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i^<span class="number">1</span>].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[S] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">graph::dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest = flow, k, i;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = cur[x]; i; i = side[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> !vis[side[i].to] <span class="keyword">and</span> dis[side[i].to] == dis[x]-side[i].cost)</span><br><span class="line">        &#123;</span><br><span class="line">            k = <span class="built_in">dfs</span>(side[i].to, <span class="built_in">min</span>(rest, side[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) dis[side[i].to] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            side[i].flow -= k;</span><br><span class="line">            side[i^<span class="number">1</span>].flow += k;</span><br><span class="line">            <span class="keyword">if</span>(!(rest -= k)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cur[x] = i, flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Primal-Dual原始对偶">Primal-Dual原始对偶</h2>
<p>这个坑我先开了，以后再填(偷懒</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 114514</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1919810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> graph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to;</span><br><span class="line">        ll flow, cost;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line">    &#125;side[M];</span><br><span class="line">    <span class="keyword">int</span> head[N], ccnt = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, ll flow, ll cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        side[++ccnt] = &#123;to, flow, cost, head[from]&#125;; head[from] = ccnt;</span><br><span class="line">        side[++ccnt] = &#123;from, <span class="number">0</span>, -cost, head[to]&#125;; head[to] = ccnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S, T;</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="keyword">int</span> pres[N], prex[N];</span><br><span class="line">    ll dis[N], h[N];</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ll,ll&gt; <span class="title">MCMF</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(u, v, w, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">MCMF</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;ll,ll&gt; <span class="title">graph::MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">dijkstra</span>(S, T))</span><br><span class="line">    &#123;</span><br><span class="line">        ll minf = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            h[i] += dis[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = prex[x])</span><br><span class="line">            minf = <span class="built_in">min</span>(minf, side[pres[x]].flow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = T; x != S; x = prex[x])</span><br><span class="line">        &#123;</span><br><span class="line">            side[pres[x]].flow -= minf;</span><br><span class="line">            side[pres[x]^<span class="number">1</span>].flow += minf;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += minf;</span><br><span class="line">        cost += h[T]*minf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph::spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> h[side[i].to] &gt; h[x]+side[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                h[side[i].to] = h[x]+side[i].cost;</span><br><span class="line">                <span class="keyword">if</span>(!vis[side[i].to])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(side[i].to);</span><br><span class="line">                    vis[side[i].to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; ll dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)</span><br><span class="line">&#123; <span class="keyword">return</span> a.dis &gt; b.dis; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">graph::dijkstra</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>&#125;); dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">top</span>().id; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>; vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = side[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(side[i].flow <span class="keyword">and</span> dis[side[i].to] &gt; dis[x]+side[i].cost+h[x]-h[side[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[side[i].to] = dis[x]+side[i].cost+h[x]-h[side[i].to];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;side[i].to, dis[side[i].to]&#125;);</span><br><span class="line">                pres[side[i].to] = i; prex[side[i].to] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有负环的费用流">有负环的费用流</h2>
<p>咕咕咕~</p>
<h1>二分图匹配</h1>
<p>以网络流的特性来看，肯定能很容易地解决二分图匹配问题，因为限制流量就可以限制每个点的匹配数、被匹配数，多重匹配问题也随之解决</p>
<p>对于二分图带权最大匹配更简单了，直接权值取负数跑最小费用最大流，再对费用取反就可以直接解决二分图带权匹配问题</p>
<p>当然费用流对于二分图最大完美匹配的问题的处理速度还是不如KM算法的，但你可以通过极致卡常过掉 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6577">	P6577</a></p>
<h1>上下界网络流</h1>
<h2 id="无源汇上下界可行流">无源汇上下界可行流</h2>
<p>为了解决亿些更复杂的问题，光是有流量上限还不行，每个边的流量都有一个上界和下界，求是否存在一个流可以满足所有边的上下界和所有点流量平衡</p>
<p>首先这个下界很烦，有这个下界我们就很难套上面的板子，于是我们想办法把这个下界消掉</p>
<p>我们可以先满足所有边的下界，这样每条边就只剩下一个 <code>r-l</code> 的上界了，可以扔到普通网络流的板子里</p>
<p>但是这样又诞生了许多问题，首先满足下界之后势必会有一些点不满足流量平衡，一些点存了流量，一些点透支了流量，我们设每个点所存的流量为 <code>val</code> ，即流入量减去流出量</p>
<p>我们需要在满足上界的条件下，把存下的流量推送给透支的流量上，达到满足流量平衡</p>
<p>于是我们得想办法让一股流从多的点流到少的点，但我们又不能凭空造流，否则不满足流量平衡，于是我们需要建一个虚拟源点汇点，因为最大流中源点汇点可以不满足流量平衡</p>
<p>所以对于 <code>val&gt;0</code> 的点，我们从 <code>S</code> 向它建一条流量为<code>val</code>的边，对于 <code>val&lt;0</code> 的点，我们从它向 <code>T</code> 建一条流量为 <code>-val</code> 的边，然后跑最大流，这样我们所有存下的流量就可以流到透支的地方去了</p>
<p>设所有存下的流量为 <code>sum</code> ，即 $ \Sigma val_i[val_i&gt;0] $，如果跑出来的流量等于 <code>sum</code> 的话，证明可以平衡掉所有的流量，即存在可行流，如果小于 <code>sum</code> 的话证明没有可行流</p>
<p>Code: <a href=".%5CCode%5C%E6%97%A0%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81.cpp">无源汇上下界可行流</a></p>
<h2 id="有源汇上下界最大流">有源汇上下界最大流</h2>
<p>这个问题多了源汇，因为源汇是不需要满足流量平衡的，所以没法直接跑出可行流</p>
<p>以下部分用<code>S</code>和<code>T</code>代表虚拟源点汇点(跑网络流实际要用的)，<code>s</code>和<code>t</code>代表题目中实际的源点和汇点</p>
<p>这时候我们就可以从 <code>t-&gt;s</code> 建一条流量为 <code>inf</code> 的边，直接转化为无源汇问题，我们跑无源汇上下界可行流即可</p>
<p>但是直接跑的话可能没有达到最大流量，因为我们只满足了下界</p>
<p>但是我们已经满足下界了，就相当于没有了下界这个条件，这时再跑一次 <code>s-&gt;t</code> 的最大流，加到答案中，就是有源汇上下界最大流的答案了</p>
<p>因为跑出可行流之后已经满足了流量平衡，这时跑最大流除了 <code>s</code> 和 <code>t</code> 也是都满足流量平衡的，然后最大流会把能跑的流量全跑完，所以就可以求出答案来</p>
<p>这里要特别注意一定要删去之前建的 <code>t-&gt;s</code> 的边，否则就是一个死循环打到你脸上</p>
<p>Code: <a href=".%5CCode%5C%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81.cpp">有源汇上下界最大流</a></p>
<h2 id="有源汇上下界最小流">有源汇上下界最小流</h2>
<p>其实跟上面差不多，最小流不就是尽量让流变小吗，我们可以先跑出可行流，然后从 <code>t-&gt;s</code> 跑一边最大流(感性理解)，减去跑出的流量，就是最小流的答案</p>
<p>就是从 <code>t-&gt;s</code> 能退回去多少就退回去多少流</p>
<h2 id="有费用的上下界网络流">有费用的上下界网络流</h2>
<p>其实就是套个费用流，注意跑最小流的时候费用也是累加而不是减去第二部分的费用(退流时走的反边已经有退回费用的功能了)</p>
<h1>例题</h1>
<p>这里是我找的一些题，题单前半部分都是水题(锻炼敲板子和基础建模能力)，后半部分有一些稍微有难度的题，可以好好想一下</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/training/172988">题单链接</a></p>
<p>经典的网络流24题，有些题还是很不错的</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/list?tag=332&amp;page=1&amp;orderBy=difficulty&amp;order=asc">网络流24题</a></p>
<h1>引用的一些资料</h1>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/victorique/p/8560656.html">网络流建模</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s1.328888.xyz/2022/06/07/zhRWk.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/09/%E8%87%AA%E5%8A%A8%E5%8F%96%E6%A8%A1%E6%95%B0%E6%9D%BF%E5%AD%90/"><img class="prev-cover" src="https://s1.328888.xyz/2022/06/07/zhh7q.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">自动取模数板子</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/09/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://s1.328888.xyz/2022/07/19/l2G1w.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数论学习笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.328888.xyz/2022/08/03/OWtcw.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ptilopsis_w</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ptilopsisw"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">查看代码推荐用夜间模式</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">关于网络流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Edmonds-Karp%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">Edmonds-Karp算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dinic%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">Dinic算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E5%BC%A7%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">当前弧优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">最小割</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">最小费用最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zkw%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">zkw费用流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Primal-Dual%E5%8E%9F%E5%A7%8B%E5%AF%B9%E5%81%B6"><span class="toc-number">4.2.</span> <span class="toc-text">Primal-Dual原始对偶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E8%B4%9F%E7%8E%AF%E7%9A%84%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-number">4.3.</span> <span class="toc-text">有负环的费用流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">二分图匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">上下界网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-number">6.1.</span> <span class="toc-text">无源汇上下界可行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">6.2.</span> <span class="toc-text">有源汇上下界最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%B0%8F%E6%B5%81"><span class="toc-number">6.3.</span> <span class="toc-text">有源汇上下界最小流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E8%B4%B9%E7%94%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">6.4.</span> <span class="toc-text">有费用的上下界网络流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">引用的一些资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/17/%E5%9B%BE%E8%AE%BA/" title="图论"><img src="https://s1.328888.xyz/2022/07/30/FhzLU.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图论"/></a><div class="content"><a class="title" href="/2022/08/17/%E5%9B%BE%E8%AE%BA/" title="图论">图论</a><time datetime="2022-08-17T02:57:00.021Z" title="发表于 2022-08-17 10:57:00">2022-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/Windows+VSCode%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20clangd/" title="Windows+VSCode 中使用 clangd"><img src="https://s1.328888.xyz/2022/07/15/LQIZp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows+VSCode 中使用 clangd"/></a><div class="content"><a class="title" href="/2022/08/09/Windows+VSCode%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20clangd/" title="Windows+VSCode 中使用 clangd">Windows+VSCode 中使用 clangd</a><time datetime="2022-08-09T08:58:22.887Z" title="发表于 2022-08-09 16:58:22">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/Command%20Runner%20%E9%80%8F%E5%BD%BB%E6%8C%87%E5%8D%97(VSCode)/" title="Command Runner 透彻指南(VSCode)"><img src="https://s1.328888.xyz/2022/06/07/zhIJy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Command Runner 透彻指南(VSCode)"/></a><div class="content"><a class="title" href="/2022/08/09/Command%20Runner%20%E9%80%8F%E5%BD%BB%E6%8C%87%E5%8D%97(VSCode)/" title="Command Runner 透彻指南(VSCode)">Command Runner 透彻指南(VSCode)</a><time datetime="2022-08-09T08:57:57.407Z" title="发表于 2022-08-09 16:57:57">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/%E8%87%AA%E5%8A%A8%E5%8F%96%E6%A8%A1%E6%95%B0%E6%9D%BF%E5%AD%90/" title="自动取模数板子"><img src="https://s1.328888.xyz/2022/06/07/zhh7q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动取模数板子"/></a><div class="content"><a class="title" href="/2022/08/09/%E8%87%AA%E5%8A%A8%E5%8F%96%E6%A8%A1%E6%95%B0%E6%9D%BF%E5%AD%90/" title="自动取模数板子">自动取模数板子</a><time datetime="2022-08-09T08:57:47.881Z" title="发表于 2022-08-09 16:57:47">2022-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/09/%E7%BD%91%E7%BB%9C%E6%B5%81/" title="网络流"><img src="https://s1.328888.xyz/2022/06/07/zhRWk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络流"/></a><div class="content"><a class="title" href="/2022/08/09/%E7%BD%91%E7%BB%9C%E6%B5%81/" title="网络流">网络流</a><time datetime="2022-08-09T08:57:36.702Z" title="发表于 2022-08-09 16:57:36">2022-08-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Ptilopsis_w</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '6fc00a26de66aa445fdc',
      clientSecret: '3eed072e6021d1c30199ad18b0d361ea46783998',
      repo: 'blog-comment',
      owner: 'Ptilopsisw',
      admin: ['Ptilopsisw'],
      id: 'de0aecd684db14cc79d61f6c4c5ba12d',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>